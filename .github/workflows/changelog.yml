name: Changelog

on:
  workflow_call:
    inputs:
      enabled:
        type: boolean
        required: true

jobs:
  changelog:
    if: inputs.enabled
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const types = {
              feat: { emoji: 'âœ¨', label: 'Features', priority: 1 },
              fix: { emoji: 'ðŸ›', label: 'Bug Fixes', priority: 2 },
              perf: { emoji: 'âš¡', label: 'Performance', priority: 3 },
              refactor: { emoji: 'â™»ï¸', label: 'Refactoring', priority: 4 },
              docs: { emoji: 'ðŸ“š', label: 'Documentation', priority: 5 },
              test: { emoji: 'ðŸ§ª', label: 'Tests', priority: 6 },
              ci: { emoji: 'ðŸ”§', label: 'CI/CD', priority: 7 },
              build: { emoji: 'ðŸ“¦', label: 'Build', priority: 8 },
              style: { emoji: 'ðŸ’Ž', label: 'Style', priority: 9 },
              chore: { emoji: 'ðŸ”¨', label: 'Chores', priority: 10 }
            };

            // Get current branch
            const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();

            // Get commits grouped by version
            const gitLog = execSync(
              'git log -200 --pretty=format:"%H|%h|%s|%an|%aI|%D" --no-merges',
              { encoding: 'utf8' }
            );

            const commitsByVersion = new Map();
            const processedShas = new Set();

            // Load existing changelog to avoid duplicates
            if (fs.existsSync('CHANGELOG.md')) {
              const existing = fs.readFileSync('CHANGELOG.md', 'utf8');
              const shaMatches = existing.matchAll(/\[`([a-f0-9]{7})`\]/g);
              for (const match of shaMatches) {
                processedShas.add(match[1]);
              }
            }

            for (const line of gitLog.split('\n').filter(l => l)) {
              const [sha, shaShort, message, author, date, refs] = line.split('|');

              if (processedShas.has(shaShort)) continue;
              if (message.includes('chore: update changelog')) continue;
              if (message.includes('Merge pull request')) continue;
              if (message.includes('Merge branch')) continue;

              // Get version from Cargo.toml at this commit
              let version = 'v0.0.0';
              try {
                const cargo = execSync(`git show ${sha}:Cargo.toml 2>/dev/null`, { encoding: 'utf8' });
                const m = cargo.match(/^version\s*=\s*"([^"]+)"/m);
                if (m) version = `v${m[1]}`;
              } catch (e) {}

              // Parse commit type
              let type = 'other';
              let scope = '';
              let desc = message;
              let issue = '';

              const issueMatch = message.match(/^#(\d+)\s+/);
              if (issueMatch) {
                issue = issueMatch[1];
                desc = message.slice(issueMatch[0].length);
              }

              const typeMatch = desc.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/);
              if (typeMatch) {
                type = typeMatch[1].toLowerCase();
                scope = typeMatch[2] || '';
                desc = typeMatch[3];
              }

              // Get author info
              let authorInfo = { name: author, avatar: '', url: '' };
              try {
                const { data } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });
                if (data.author) {
                  authorInfo = {
                    name: data.author.login,
                    avatar: data.author.avatar_url,
                    url: data.author.html_url
                  };
                }
              } catch (e) {}

              // Detect branch from refs or PR
              let branch = currentBranch;
              if (refs) {
                const branchMatch = refs.match(/origin\/(\w+)/);
                if (branchMatch) branch = branchMatch[1];
              }

              if (!commitsByVersion.has(version)) {
                commitsByVersion.set(version, { commits: [], date: date.split('T')[0] });
              }

              commitsByVersion.get(version).commits.push({
                sha, shaShort, type, scope, desc, issue, author: authorInfo, date, branch
              });
            }

            // Sort versions
            const sortedVersions = [...commitsByVersion.keys()].sort((a, b) => {
              const pa = a.slice(1).split('.').map(Number);
              const pb = b.slice(1).split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                if ((pa[i] || 0) !== (pb[i] || 0)) return (pb[i] || 0) - (pa[i] || 0);
              }
              return 0;
            });

            // Build changelog
            let changelog = '# Changelog\n\n';
            changelog += '> Auto-generated from commits. Grouped by type, sorted by priority.\n\n';
            changelog += '---\n\n';

            for (const version of sortedVersions) {
              const { commits, date } = commitsByVersion.get(version);
              if (commits.length === 0) continue;

              // Version header with metadata
              const prevVersion = sortedVersions[sortedVersions.indexOf(version) + 1];
              const compareLink = prevVersion
                ? `[compare](${repoUrl}/compare/${prevVersion}...${version})`
                : '';

              changelog += '## ' + version + '\n\n';
              const commitWord = commits.length > 1 ? 'commits' : 'commit';
              const cmpLink = compareLink ? ' Â· ' + compareLink : '';
              changelog += '> ðŸ“… ' + date + ' Â· ' + commits.length + ' ' + commitWord + cmpLink + '\n\n';

              // Group by type
              const byType = new Map();
              for (const c of commits) {
                const t = types[c.type] ? c.type : 'other';
                if (!byType.has(t)) byType.set(t, []);
                byType.get(t).push(c);
              }

              // Sort types by priority
              const sortedTypes = [...byType.keys()].sort((a, b) => {
                return (types[a]?.priority || 99) - (types[b]?.priority || 99);
              });

              for (const type of sortedTypes) {
                const typeInfo = types[type] || { emoji: 'ðŸ“', label: 'Other' };
                const typeCommits = byType.get(type);

                // Collapsible if > 5 items
                const needsCollapse = typeCommits.length > 5;

                if (needsCollapse) {
                  changelog += '<details>\n';
                  changelog += '<summary>' + typeInfo.emoji + ' <strong>' + typeInfo.label + '</strong> (' + typeCommits.length + ')</summary>\n\n';
                } else {
                  changelog += '### ' + typeInfo.emoji + ' ' + typeInfo.label + '\n\n';
                }

                // Table format
                changelog += '| Commit | Description | Author | Branch |\n';
                changelog += '|:-------|:------------|:------:|:------:|\n';

                for (const c of typeCommits) {
                  const commitLink = `[\`${c.shaShort}\`](${repoUrl}/commit/${c.sha})`;
                  const issueLink = c.issue ? `[#${c.issue}](${repoUrl}/issues/${c.issue}) ` : '';
                  const scopeBadge = c.scope ? `\`${c.scope}\` ` : '';
                  const desc = `${issueLink}${scopeBadge}${c.desc}`;
                  const avatar = c.author.avatar
                    ? `[<img src="${c.author.avatar}" width="20" title="${c.author.name}"/>](${c.author.url})`
                    : c.author.name;
                  const branch = `\`${c.branch}\``;

                  changelog += `| ${commitLink} | ${desc} | ${avatar} | ${branch} |\n`;
                }

                if (needsCollapse) {
                  changelog += '\n</details>\n\n';
                } else {
                  changelog += '\n';
                }
              }

              changelog += '---\n\n';
            }

            fs.writeFileSync('CHANGELOG.md', changelog.trim() + '\n');
            console.log(`Generated changelog with ${sortedVersions.length} versions`);

      - run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git diff --staged --quiet || git commit -m "chore: update changelog"
          git push
