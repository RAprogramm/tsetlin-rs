name: CI

on:
  push:
    branches: [main]
  pull_request:

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: Quick checks (parallel, no deps)
  # ============================================================================

  fmt:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: dtolnay/rust-toolchain@nightly
        with:
          components: rustfmt
      - run: cargo +nightly fmt --all -- --check

  check:
    name: Check (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: ${{ matrix.os }}
          shared-key: stable

      - run: cargo check --features "parallel,serde"

  check-simd:
    name: Check SIMD (nightly)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@nightly

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: simd
          shared-key: nightly

      - run: cargo +nightly check --all-features

  check-no-std:
    name: Check no_std
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: no-std
          shared-key: stable

      - run: cargo check --no-default-features

  # ============================================================================
  # STAGE 2: Linting (needs: check)
  # ============================================================================

  clippy:
    name: Clippy
    needs: check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: clippy
          shared-key: stable

      - run: cargo clippy --all-targets --features "parallel,serde" -- -D warnings

  doc:
    name: Documentation
    needs: check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: doc
          shared-key: stable

      - run: cargo doc --no-deps --features "parallel,serde"
        env:
          RUSTDOCFLAGS: -Dwarnings

  # ============================================================================
  # STAGE 3: Testing (needs: clippy)
  # ============================================================================

  test:
    name: Test (${{ matrix.os }}, ${{ matrix.features || 'default' }})
    needs: clippy
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        features: ["", "serde", "parallel", "parallel,serde"]
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: test-${{ matrix.os }}
          shared-key: stable
          cache-targets: true

      - name: Run tests
        run: cargo test --features "${{ matrix.features }}"

  test-simd:
    name: Test SIMD (nightly)
    needs: check-simd
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@nightly

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: test-simd
          shared-key: nightly
          cache-targets: true

      - run: cargo +nightly test --all-features

  # ============================================================================
  # STAGE 4: Coverage (needs: test, ubuntu only)
  # ============================================================================

  coverage:
    name: Coverage
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - uses: taiki-e/install-action@cargo-llvm-cov

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: coverage
          shared-key: stable
          cache-targets: true

      - name: Run tests with coverage
        run: |
          cargo llvm-cov --features "parallel,serde" --lcov --output-path lcov.info
          cargo test --features "parallel,serde" -- -Z unstable-options --format json > test-results.json || true

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
          fail_ci_if_error: false

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  # ============================================================================
  # STAGE 5: Changelog (every push, skip bot commits)
  # ============================================================================

  changelog:
    name: Changelog
    runs-on: ubuntu-latest
    if: "github.event_name == 'push' && !contains(github.event.head_commit.message, 'chore: update changelog')"
    needs: [test, doc]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Generate Changelog
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Version from Cargo.toml
            const cargo = fs.readFileSync('Cargo.toml', 'utf8');
            const versionMatch = cargo.match(/^version\s*=\s*"([^"]+)"/m);
            const currentVersion = versionMatch ? `v${versionMatch[1]}` : 'v0.0.0';
            console.log(`Current version: ${currentVersion}`);

            // Parse existing changelog
            let existingSHAs = new Set();
            let existingVersions = new Set();
            let unreleasedEntries = [];
            let versionedSections = [];

            if (fs.existsSync('CHANGELOG.md')) {
              const existing = fs.readFileSync('CHANGELOG.md', 'utf8');

              // Extract all SHAs already in changelog (7-char short SHA)
              const shaRegex = /\[`([a-f0-9]{7})`\]/g;
              let m;
              while ((m = shaRegex.exec(existing)) !== null) {
                existingSHAs.add(m[1]);
              }

              // Extract Unreleased section entries
              const unreleasedMatch = existing.match(/## Unreleased\n\n([\s\S]*?)(?=\n## v|$)/);
              if (unreleasedMatch && unreleasedMatch[1].trim()) {
                unreleasedEntries = unreleasedMatch[1].trim().split('\n\n').filter(e => e.startsWith('- ['));
              }

              // Extract all versioned sections (preserve completely)
              const versionedMatch = existing.match(/\n(## v[\d.]+[\s\S]*)/);
              if (versionedMatch) {
                versionedSections = versionedMatch[1].split(/(?=\n## v[\d.]+)/).filter(s => s.trim());
              }

              // Track existing versions
              const versionRegex = /^## (v[\d.]+)/gm;
              while ((m = versionRegex.exec(existing)) !== null) {
                existingVersions.add(m[1]);
              }
            }

            console.log(`Existing versions: ${[...existingVersions].join(', ') || 'none'}`);
            console.log(`Unreleased entries: ${unreleasedEntries.length}`);
            console.log(`Existing SHAs: ${existingSHAs.size}`);

            // Get new commits not in changelog (limit to last 100)
            const gitLog = execSync('git log -100 --pretty=format:"%H|%h|%s|%an" --no-merges', { encoding: 'utf8' });
            const newCommits = [];

            for (const line of gitLog.split('\n').filter(l => l)) {
              const [sha, shaShort, message, author] = line.split('|');

              // Skip if already documented or is changelog/merge commit
              if (existingSHAs.has(shaShort)) continue;
              if (message.includes('chore: update changelog')) continue;
              if (message.includes('Merge pull request')) continue;

              try {
                const { data: commitData } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                const ghAuthor = commitData.author;
                const authorAvatar = ghAuthor?.avatar_url
                  ? `[<img src="${ghAuthor.avatar_url}" width="20" height="20" style="border-radius:50%" title="${ghAuthor.login}"/>](${ghAuthor.html_url})`
                  : `**${author}**`;

                // Convert #123 to issue/PR links
                const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
                let linkedMessage = message.replace(/#(\d+)/g, `[#$1](${repoUrl}/issues/$1)`);

                // Parse conventional commit and add type badge
                const typeMatch = linkedMessage.match(/^(\[#\d+\]\([^)]+\)\s+)?(\w+)(\([^)]+\))?:\s*(.+)$/);
                if (typeMatch) {
                  const [, issue = '', type, scope = '', desc] = typeMatch;
                  const types = {
                    feat: 'âœ¨', fix: 'ðŸ›', docs: 'ðŸ“š', style: 'ðŸ’Ž',
                    refactor: 'â™»ï¸', perf: 'âš¡', test: 'ðŸ§ª', build: 'ðŸ“¦',
                    ci: 'ðŸ”§', chore: 'ðŸ”¨', revert: 'âª'
                  };
                  const emoji = types[type] || 'ðŸ“';
                  linkedMessage = `${issue}${emoji} ${type}${scope}: ${desc}`;
                }

                newCommits.push(`- [\`${shaShort}\`](${commitData.html_url}) ${linkedMessage}\n  ${authorAvatar}`);
              } catch (e) {
                console.log(`Skip commit ${shaShort}: ${e.message}`);
              }
            }

            console.log(`New commits found: ${newCommits.length}`);

            // Build changelog
            let changelog = '# Changelog\n\n---\n\n';

            const isMain = context.ref === 'refs/heads/main';
            const isNewVersion = !existingVersions.has(currentVersion);

            // Combine new commits with existing unreleased
            const allUnreleased = [...newCommits, ...unreleasedEntries];

            if (isMain && isNewVersion && allUnreleased.length > 0) {
              // NEW VERSION: Move all unreleased to version section
              console.log(`Creating new version section: ${currentVersion}`);
              changelog += `## ${currentVersion}\n\n`;
              changelog += allUnreleased.join('\n\n') + '\n\n';
            } else {
              // NO NEW VERSION: Keep in Unreleased
              changelog += '## Unreleased\n\n';
              if (allUnreleased.length > 0) {
                changelog += allUnreleased.join('\n\n') + '\n\n';
              }
            }

            // Append all existing versioned sections (NEVER modify or delete)
            if (versionedSections.length > 0) {
              changelog += versionedSections.join('\n');
            }

            fs.writeFileSync('CHANGELOG.md', changelog);
            console.log(`Changelog updated. New commits: ${newCommits.length}`);

      - name: Commit Changelog
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git diff --staged --quiet || git commit -m "chore: update changelog"
          git push

  # ============================================================================
  # STAGE 6: Publish to crates.io (main only, new version only)
  # ============================================================================

  publish:
    name: Publish
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [test, test-simd, coverage]
    steps:
      - uses: actions/checkout@v6

      - uses: dtolnay/rust-toolchain@stable

      - name: Check version and publish
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATESIO }}
        run: |
          VERSION=$(grep -m1 '^version' Cargo.toml | sed 's/.*"\(.*\)"/\1/')
          echo "Local version: $VERSION"

          # Check if version exists on crates.io
          PUBLISHED=$(curl -s "https://crates.io/api/v1/crates/tsetlin-rs" | jq -r ".versions[]?.num // empty" | grep -x "$VERSION" || true)

          if [ -n "$PUBLISHED" ]; then
            echo "Version $VERSION already published, skipping"
          else
            echo "Version $VERSION not found on crates.io, publishing..."
            cargo publish || echo "Publish failed or version already exists"
          fi

  # ============================================================================
  # STAGE 7: GitHub Release (main only, if version in changelog but no release)
  # ============================================================================

  release:
    name: Release
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [publish, changelog]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Check and create release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get version from Cargo.toml
          VERSION=$(grep -m1 '^version' Cargo.toml | sed 's/.*"\(.*\)"/\1/')
          TAG="v$VERSION"
          echo "Version: $VERSION, Tag: $TAG"

          # Check if version section exists in CHANGELOG
          if ! grep -q "## $TAG" CHANGELOG.md; then
            echo "Version $TAG not found in CHANGELOG.md, skipping release"
            exit 0
          fi

          # Check if release already exists
          if gh release view "$TAG" &>/dev/null; then
            echo "Release $TAG already exists, skipping"
            exit 0
          fi

          # Extract release notes from CHANGELOG (content between ## vX.Y.Z and next ## or EOF)
          NOTES=$(awk "/^## $TAG$/,/^## v[0-9]/{if(/^## v[0-9]/ && !/^## $TAG$/)exit; print}" CHANGELOG.md | tail -n +2)

          if [ -z "$NOTES" ]; then
            NOTES="Release $TAG"
          fi

          echo "Creating release $TAG..."
          echo "$NOTES" | gh release create "$TAG" \
            --title "$TAG" \
            --notes-file - \
            --verify-tag || gh release create "$TAG" \
            --title "$TAG" \
            --notes-file - \
            --target main

          echo "Release $TAG created successfully!"

  # ============================================================================
  # Final gate (for branch protection)
  # ============================================================================

  ci-success:
    name: CI Success
    if: always()
    needs: [fmt, check, check-simd, check-no-std, clippy, doc, test, test-simd, coverage]
    runs-on: ubuntu-latest
    steps:
      - name: Check all jobs
        run: |
          results=("${{ needs.fmt.result }}" "${{ needs.check.result }}" \
                   "${{ needs.check-simd.result }}" "${{ needs.check-no-std.result }}" \
                   "${{ needs.clippy.result }}" "${{ needs.doc.result }}" \
                   "${{ needs.test.result }}" "${{ needs.test-simd.result }}" \
                   "${{ needs.coverage.result }}")
          for r in "${results[@]}"; do
            if [[ "$r" != "success" ]]; then
              echo "CI failed"
              exit 1
            fi
          done
          echo "All CI checks passed!"
